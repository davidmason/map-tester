;(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
var loadImages = require('image-batch-loader'),
    Game = require('crtrdg-gameloop'),
    Mouse = require('crtrdg-mouse');

var canvas = document.getElementById('main-canvas');
var context = canvas.getContext('2d');

var mapFile = function () {
  return window.location.search.split("=")[1];
}

$.getJSON(mapFile())
.fail(function( jqxhr, textStatus, error ) {
    var err = textStatus + ", " + error;
    console.log( "Request Failed: " + err );
})
.done(testTheMap);

function testTheMap (map) {
  document.getElementById('title').innerText = map.name;
  
  if (canvas.getContext) {
    drawMapInContext(context);
  } else {
    console.log("Canvas not supported.")
  }

  function drawMapInContext(context) {

    loadImageThenAction(map.background.file, drawBackground());

    function drawBackground() {
      return function (image) {
        context.drawImage(image, map.background.left, map.background.top);
        loadTiles();
      }
    }

    function loadTiles() {
      var tileImageFiles = [];
      for (var tile in map.tiles) {
        tileImageFiles.push(map.tiles[tile].file);
      }
      loadImages(tileImageFiles, function (images) {
        // draw the images
        var toDraw = map.midground;
        var tiles = map.tiles;
        var name, x, y, img;

        for (var i = 0; i < toDraw.length; i++) {
          name = toDraw[i][0];
          img = images[tiles[name].file];
          x = toDraw[i][1][0];
          y = toDraw[i][1][1];

          context.drawImage(img, x, y);
        }

      });
    }

    function loadImageThenAction (imageFile, action) {
      var img = new Image();
      img.addEventListener('load', function() {
        action(img);
      }, false);
      img.src = imageFile;
    }
  }
}

var game = new Game({
  canvas: 'main-canvas',
  width: 4000,
  height: 1200,
  backgroundColor: 'rgba(0,0,0,0)'
});

var markerSize = 10;

var mouse = new Mouse(game);
mouse.on('click', function(location){
  var x = location.x - markerSize / 2,
      y = location.y - markerSize / 2,
      w = h = markerSize;
  context.fillStyle = '#333';
  context.strokeStyle = '#aaa';
  context.fillRect(x, y, w, h);
  context.strokeRect(x, y, w, h);

  context.font = "25px Helvetica";
  context.textAlign = "center";

  var text = "(" + location.x + ", " + location.y + ")";
  context.fillText(text, location.x, location.y - 15 );
  context.strokeText(text, location.x, location.y - 15 );
});

},{"crtrdg-gameloop":4,"crtrdg-mouse":7,"image-batch-loader":9}],2:[function(require,module,exports){
var process=require("__browserify_process");if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (typeof emitter._events[type] === 'function')
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

},{"__browserify_process":3}],3:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],4:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var requestAnimationFrame = require('raf');
var inherits = require('inherits');

module.exports = Game;
inherits(Game, EventEmitter);

function Game(options){
  var options = options || {};

  EventEmitter.call(this);
  var self = this;
  
  if (!options.canvas){
    this.canvas = document.createElement('canvas');
    this.canvas.id = 'game';
    document.body.appendChild(this.canvas);
  } else if (typeof options.canvas === 'string'){
    this.canvas = document.getElementById(options.canvas);
  } else if (typeof options.canvas === 'object' && options.canvas.tagName) {
    this.canvas = options.canvas
  }

  this.context = this.canvas.getContext('2d');
  this.width = this.canvas.width = options.width || window.innerWidth;
  this.height = this.canvas.height = options.height || window.innerHeight;
  this.backgroundColor = options.backgroundColor || '#E187B8';

  this.ticker = requestAnimationFrame(this.canvas);
  this.paused = false;

  if (options.maxListeners){
    this.setMaxListeners(options.maxListeners);
  } else {
    this.setMaxListeners(0);
  }

  window.addEventListener('load', function(){
    self.start();
  });
}

Game.prototype.start = function(){
  var self = this;
  this.emit('start');
  this.ticker.on('data', function(interval) {
    self.update(interval);
    self.draw();
  });
};

Game.prototype.pause = function(){
  this.paused = true;
  this.ticker.pause();
  this.emit('pause');
};

Game.prototype.resume = function(){
  var self = this;
  
  this.paused = false;
  this.ticker = requestAnimationFrame(this.canvas);
  this.ticker.on('data', function(interval) {
    self.update(interval);
    self.draw();
  });

  this.emit('resume');
};

Game.prototype.update = function(interval){
  if (this.currentScene){
    this.sceneManager.update(interval);
  }
  this.emit('update', interval);
};

Game.prototype.draw = function(){
  if (this.currentScene){
    this.context.fillStyle = this.currentScene.backgroundColor;
    this.sceneManager.draw(this.context);
  } else {
    this.context.fillStyle = this.backgroundColor;
  }
  this.context.fillRect(0, 0, this.width, this.height);
  this.emit('draw', this.context)
};
},{"events":2,"inherits":5,"raf":6}],5:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],6:[function(require,module,exports){
module.exports = raf

var EE = require('events').EventEmitter
  , global = typeof window === 'undefined' ? this : window
  , now = global.performance && global.performance.now ? function() {
    return performance.now()
  } : Date.now || function () {
    return +new Date()
  }

var _raf =
  global.requestAnimationFrame ||
  global.webkitRequestAnimationFrame ||
  global.mozRequestAnimationFrame ||
  global.msRequestAnimationFrame ||
  global.oRequestAnimationFrame ||
  (global.setImmediate ? function(fn, el) {
    setImmediate(fn)
  } :
  function(fn, el) {
    setTimeout(fn, 0)
  })

function raf(el) {
  var now = raf.now()
    , ee = new EE

  ee.pause = function() { ee.paused = true }
  ee.resume = function() { ee.paused = false }

  _raf(iter, el)

  return ee

  function iter(timestamp) {
    var _now = raf.now()
      , dt = _now - now
    
    now = _now

    ee.emit('data', dt)

    if(!ee.paused) {
      _raf(iter, el)
    }
  }
}

raf.polyfill = _raf
raf.now = now


},{"events":2}],7:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');

module.exports = Mouse;
inherits(Mouse, EventEmitter);

function Mouse(game){
  this.game = game || {};
  this.el = game.canvas;
  this.initializeListeners();
}

Mouse.prototype.initializeListeners = function(){
  var self = this;

  this.el.addEventListener('click', function(e){
    e.preventDefault();
    
    self.calculateOffset(e, function(location){
      self.emit('click', location);
    });
    return false;
  }, false);

  this.el.addEventListener('mousedown', function(e){
    e.preventDefault();

    self.calculateOffset(e, function(location){
      self.emit('mousedown', location);
    });
    return false;
  }, false);

  this.el.addEventListener('mouseup', function(e){
    e.preventDefault();

    self.calculateOffset(e, function(location){
      self.emit('mouseup', location);
    });

    return false;
  }, false);

  this.el.addEventListener('mousemove', function(e){
    e.preventDefault();

    self.calculateOffset(e, function(location){
      self.emit('mousemove', location);
    });
    return false;
  }, false);
};

Mouse.prototype.calculateOffset = function(e, callback){
  var canvas = e.target;
  var offsetX = canvas.offsetLeft - canvas.scrollLeft;
  var offsetY = canvas.offsetTop - canvas.scrollTop;

  var location = {
    x: e.pageX - offsetX,
    y: e.pageY - offsetY
  };

  callback(location);
}

},{"events":2,"inherits":8}],8:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],9:[function(require,module,exports){
module.exports = function (imagePaths, callback) {
  var images = {};
  var allLoaded = false;
  var toLoad = imagePaths.length;
  for (var i=0; i < imagePaths.length; i++) {
    var img = new Image();
    images[imagePaths[i]] = img;
    img.addEventListener('load', function() {
      toLoad -= 1;
      allLoaded = toLoad == 0;
      if (allLoaded) {
        callback(images);
      }
    }, false);
    img.src = imagePaths[i];
  }
};
},{}]},{},[1])
;